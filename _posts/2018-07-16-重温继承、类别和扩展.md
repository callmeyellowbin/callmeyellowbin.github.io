---
layout:     post
title:      重温继承、类别和扩展
#subtitle:   学习对象初始化
date:      2018-07-16
author:     Hoben Wong
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - iOS
    - Objective-C
---
距离自己探索iOS已经过了两个月了，现在回来重温一下这个知识点，加深一下记忆。本次参考的有

[iOS分类(category),类扩展(extension)—史上最全攻略](https://blog.csdn.net/u012946824/article/details/51799664)

[深入浅出理解分类(category）和类扩展(extension)](https://www.jianshu.com/p/75818790c1ed)

[2018-05-28 类别、委托与协议](https://www.jianshu.com/p/462b836986cf)

### 一.类别（Category）
#### 1) 为什么要有类别？
类别存在的意义是什么？先看一下以下场景：

- 场景一（别给子类用）
---
有一个项目由多个开发人员同时维护着同一个类，这时候产品的需求让A只能给当前的类`Current`添加一个方法`method`，但是这个`Current`是个大类，有很多的子类继承于这个类的，什么`Son`、`Daughter`啊之类的，如果直接粗暴地将`method`贴在`Current`里面，那么那些子类也就可以拥有这个方法了，这显然不是最佳方案。

---
- 场景二（基于官方提供的库来改）
---
有一天，一个项目里面要获得`NSString`里面是否包含敏感字符，如果我们一个个方法去加，这么多个文件，不得加到猴年马月，就算加完了，以后又来多一个敏感字符，我的天，又多了几个小时的工作量。

---

以上两种场景都是继承面临的窘境，虽说继承在面向对象编程的确给代码的重用带来了不少的方便，但是随之而来的就是`私有性保障`这一难关，我到底要给谁用，不能给谁用，似乎在一个超级超级大的父类中，很难去想出一个解决方案。

类别的存在，就是为以上情景应运而生的。他可以在`不修改`原来类的基础上，为一个类`扩展`方法。

#### 2) 类别不能做的事情
- 只能添加方法，不能添加成员变量，也就是说，如果在类别里面定义了`@property`的话，是不能使用`setter`和`getter`的。（其实也是可以的，但是要基于runtime来搞，在这里先不扩展）

- 只能访问原有类中`@protect`和`@public`形式的成员变量，也就是说，`@private`变量对于类别和子类来说都是一样的，只能通过方法来访问。

#### 3) 同名方法调用顺序
类别和原有类的命名相冲突的话，会优先调用类别里面的方法，即忽略原有类的变量，因此，同名方法调用的优先级是`分类 > 本类 > 父类`，但是不建议在开发中覆盖原有类的方法。

#### 4) 同名多类别调用顺序
如果多个类别中都有和原有类中同名的方法，则调用顺序由编译器决定，编译器会执行最后一个参与编译的类别方法。

### 二.类扩展（Extension）
类扩展是类别的一个特例，即少了分类的名称，也可以称为匿名分类。作用是为一个类添加一些`私有`的成员变量和方法，格式如下：
```
@interface XXX ()
//私有属性
//私有方法（如果不实现，编译时会报警,Method definition for 'XXX' not found）
@end
```
#### 1) 为什么要有类扩展？
一般来说，.m文件不像.h文件一样暴露在外部，所以.m文件中声明的方法外面是很难知道的（虽然实际上可以调用，但是这样做很蠢），那么我们就可以把信息分为`公开`和`隐藏`两种信息，把`公开`的信息（变量、属性、方法等）定义在.h文件中，而把`隐藏`的信息定义在类扩展中，这样就可以隔离接口和实现了。

所以类扩展的存在可以解决两大问题：
1. 定义类私有方法的地方

2. 实现对外`readonly`，对内`readwrite`的属性，也就是说，可以在.h文件中定义一个对外是`readonly`的属性，在.m文件中的`@interface`部分重新定义这个属性是`readwrite`的。

3. 实现私有变量、方法和属性，只能被当前类访问，则写在类扩展里面。

#### 2) 类扩展和类别的区别

1. 类别中原则上只能增加方法，不能增加属性（排除用`runtime`解决`setter/geter`问题的方法）
  类扩展不仅可以增加方法，还可以增加实例变量（或属性），只是改实例变量是私有的。

2. 类别中的方法没被实现，编译器不会报警
  类扩展中声明的方法没被实现，编译器会报警（这是因为类扩展是在编译阶段被添加到类中，而类别是在运行时添加到类中）

3. 类扩展不能像类别那样拥有独立的实现部分（`@implementation`），也就是说，类扩展所声明的方法必须依托在对应的类的实现部分来实现。
